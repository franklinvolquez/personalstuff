<?xml version="1.0" encoding="utf-8"?>
<components:OptionsPanel implements="fr.kapit.lab.demo.ui.components.IConfigPanel"
						 xmlns:component="fr.kapit.lab.demo.panel.component.*"
						 xmlns:components="fr.kapit.lab.demo.common.components.*"
						 xmlns:forms="fr.kapit.lab.demo.forms.*"
						 xmlns:fx="http://ns.adobe.com/mxml/2009"
						 xmlns:mx="library://ns.adobe.com/flex/mx"
						 xmlns:s="library://ns.adobe.com/flex/spark"
						 skinClass="fr.kapit.lab.demo.common.skins.OptionsLayoutPanelSkin"
						 width="100%"
						 creationComplete="this_creationCompleteHandler(event)"
						 includeInLayout="{!appModel.diagrammerModel.isEmpty}"
						 visible="{!appModel.diagrammerModel.isEmpty}" xmlns:buttons="fr.kapit.lab.demo.buttons.*"
						 >

	<fx:Library>
		<fx:Definition name="HSeparator">
			<s:Group width="100%" height="1">
				<s:Rect left="0" right="0" top="0" bottom="0">
					<s:fill>
						<s:SolidColor color="0xE6E6E6" />
					</s:fill>
				</s:Rect>
			</s:Group>
		</fx:Definition>
	</fx:Library>

	<fx:Declarations>
		<s:ArrayCollection id="layoutList">
			<component:LayoutSelectorHeaderButton 
												  icon="{EmbeddedAssets.IMG_LAYOUT_HIERARCHICAL}"
												  label="Hierarchical tree"
												  layoutType="{HierarchicalLayout.ID}"
												  state="HierarchicalLayout"
												  tooltip="Hierarchical tree : HierarchicalLayout"
												  />
			<component:LayoutSelectorHeaderButton 
												  icon="{EmbeddedAssets.IMG_LAYOUT_HIERARCHICAL_CYCLIC}"
												  label="Hierarchical cyclic"
												  layoutType="{SugiyamaLayout.ID}"
												  state="SugiyamaLayout"
												  tooltip="Hierarchical cyclic : SugiyamaLayout"
												  />
			<component:LayoutSelectorHeaderButton 
												  icon="{EmbeddedAssets.IMG_LAYOUT_ORTHOGONAL}"
												  label="Orthogonal"
												  layoutType="{OrthogonalLayout.ID}"
												  state="OrthogonalLayout"
												  tooltip="Orthogonal : OrthogonalLayout"
												  />
			<component:LayoutSelectorHeaderButton 
												  icon="{EmbeddedAssets.IMG_LAYOUT_CIRCULAR}"
												  label="Circular"
												  layoutType="{SingleCycleCircularLayout.ID}"
												  state="SingleCycleCircularLayout"
												  tooltip="Circular : SingleCycleCircularLayout"
												  />
			<component:LayoutSelectorHeaderButton 
												  icon="{EmbeddedAssets.IMG_LAYOUT_BALLOON}"
												  label="Balloon"
												  layoutType="{BalloonLayout.ID}"
												  state="BalloonLayout"
												  tooltip="Balloon : BalloonLayout"
												  />
			<component:LayoutSelectorHeaderButton 
												  icon="{EmbeddedAssets.IMG_LAYOUT_RADIAL}"
												  label="Radial"
												  layoutType="{RadialLayout.ID}"
												  state="RadialLayout"
												  tooltip="Radial : RadialLayout"
												  />
			<component:LayoutSelectorHeaderButton 
												  icon="{EmbeddedAssets.IMG_LAYOUT_ORGANIC}"
												  label="Organic"
												  layoutType="{StaticGEMLayout.ID}"
												  state="StaticGEMLayout"
												  tooltip="Organic : StaticGEMLayout"
												  />
		</s:ArrayCollection>

		<!-- true / false , labeled as "yes" / "no" -->
		<s:ArrayCollection id="booleans">
			<fx:Object label="Yes" value="{true}" hint="true" />
			<fx:Object label="No" value="{false}" hint="false" />
		</s:ArrayCollection>

		<!-- default spacing values, used to modify the laoyout -->
		<s:ArrayCollection id="defaultSpacings">
			<fx:Object label="Low" value="{20}" hint="20" />
			<fx:Object label="Medium" value="{60}" hint="60" />
			<fx:Object label="High" value="{200}" hint="200" />
		</s:ArrayCollection>

		<!-- default angle values, used for circular and balloon layout -->
		<s:ArrayCollection id="defaultAngles">
			<fx:Object label="360" value="{360}" hint="360" />
			<fx:Object label="180" value="{180}" hint="180" />
		</s:ArrayCollection>

		<s:ArrayCollection id="rootSelectionPolicies">
			<fx:Object label="Directed"
					   value="{RootSelectionType.DIRECTED_ROOT_SELECTION}"
					   hint="RootSelectionType.DIRECTED_ROOT_SELECTION"
					   />
			<fx:Object label="Most closed"
					   value="{RootSelectionType.MOST_CLOSED_ROOT_SELECTION}"
					   hint="RootSelectionType.MOST_CLOSED_ROOT_SELECTION"
					   />
			<fx:Object label="Most surrounded"
					   value="{RootSelectionType.MOST_SURROUNDED_ROOT_SELECTION}"
					   hint="RootSelectionType.MOST_SURROUNDED_ROOT_SELECTION"
					   />
			<fx:Object label="Most weighted"
					   value="{RootSelectionType.MOST_WEIGHTED_ROOT_SELECTION}"
					   hint="RootSelectionType.MOST_WEIGHTED_ROOT_SELECTION"
					   />
		</s:ArrayCollection>

		<s:ArrayCollection id="edgeDrawingTypes">
			<fx:Object label="Straight" value="{EdgeDrawType.STRAIGHT_LINE}"
					   hint="EdgeDrawType.STRAIGHT_LINE"
					   />
			<fx:Object label="Straight polyline" value="{EdgeDrawType.STRAIGHT_POLYLINE}"
					   hint="EdgeDrawType.STRAIGHT_POLYLINE"
					   />
			<fx:Object label="Curved polyline" value="{EdgeDrawType.CURVED_POLYLINE}"
					   hint="EdgeDrawType.CURVED_POLYLINE"
					   />
			<fx:Object label="Orthogonal polyline"
					   value="{EdgeDrawType.ORTHOGONAL_STRAIGHT_POLYLINE}"
					   hint="EdgeDrawType.ORTHOGONAL_STRAIGHT_POLYLINE"
					   />
			<fx:Object label="Orthogonal curved"
					   value="{EdgeDrawType.ORTHOGONAL_CURVED_POLYLINE}"
					   hint="EdgeDrawType.ORTHOGONAL_CURVED_POLYLINE"
					   />
		</s:ArrayCollection>
		
	</fx:Declarations>

	<fx:Script>
	<![CDATA[
		import flashx.textLayout.events.ModelChange;
		
		import fr.kapit.datavisualization.assets.EmbeddedAssets;
		import fr.kapit.diagrammer.base.uicomponent.DiagramGroup;
		import fr.kapit.diagrammer.base.uicomponent.container.DiagramTable;
		import fr.kapit.lab.demo.model.ApplicationModel;
		import fr.kapit.lab.demo.models.ILayoutModel;
		import fr.kapit.lab.demo.popup.ErrorPopup;
		import fr.kapit.layouts.algorithms.balloon.BalloonLayout;
		import fr.kapit.layouts.algorithms.circular.SingleCycleCircularLayout;
		import fr.kapit.layouts.algorithms.forcedirected.fade.ProgressiveFadeLayout;
		import fr.kapit.layouts.algorithms.forcedirected.gem.StaticGEMLayout;
		import fr.kapit.layouts.algorithms.hierarchical.HierarchicalLayout;
		import fr.kapit.layouts.algorithms.orthogonal.OrthogonalLayout;
		import fr.kapit.layouts.algorithms.radial.RadialLayout;
		import fr.kapit.layouts.algorithms.sugiyama.SugiyamaLayout;
		import fr.kapit.layouts.constants.EdgeDrawType;
		import fr.kapit.layouts.constants.OrientationType;
		import fr.kapit.layouts.constants.RootSelectionType;
		import fr.kapit.visualizer.events.VisualizerEvent;
		
		import mx.core.IFlexDisplayObject;
		import mx.events.FlexEvent;
		import mx.managers.PopUpManager;
		
		import spark.events.IndexChangeEvent;

		/**
		 * @private
		 * Reference to the application model.
		 */
		private var _applicationModel:ApplicationModel = null;

		/**
		 * @private
		 * Instance of popup to display error on layouts
		 */
		private var _layoutErrorPopup:IFlexDisplayObject;

		private var _lastSelectedLayout:int = 0;

		private var _previousSelectedLayout:*;

		[Bindable]
		private var hasGroup:Boolean


		/**
		 * Reference to the current layoutModel; the layoutModel is a wrapper
		 * around the visulizer.layout property
		 */
		public function get layoutModel():ILayoutModel
		{
			if (!appModel)
			{
				return null;
			}
			if (!appModel.diagrammerModel)
			{
				return null;
			}

			return appModel.diagrammerModel.layoutModel;
		}

		/**
		 * Reference to the current application model.
		 */
		[Bindable]
		public function get appModel():ApplicationModel
		{
			return _applicationModel;
		}

		/** @private */
		public function set appModel(value:ApplicationModel):void
		{
			_applicationModel = value;
		}

		public function layoutCommitComplete(event:VisualizerEvent):void
		{
		}

		public function onElementCreated(event:VisualizerEvent):void
		{
			hasGroup=(appModel.diagrammer.graph.metaNodes.length != 0);
		}

		[Bindable]
		public var enableControls:Boolean = true;

		protected function layoutSelector_changeHandler(event:IndexChangeEvent =null):void
		{
			if (!appModel.diagrammerModel)
			{
				return;
			}

			layoutSelector.requireSelection = true;//no layout is selected after we import a graph. 
			//But we don't allow users to switch off manually a layout
			var hadTables:Boolean = false;
			var hadGroups:Boolean = false;
			_previousSelectedLayout = appModel.diagrammerModel.layoutID;
			/*
			* If there is some tables or groups in graph, the layout "organic animated"
			* is bugged, so the user is not allowed to launch it
			*/
			if (layoutSelector.selectedItem.layoutType == ProgressiveFadeLayout.ID)
			{
				var nodesMap:Dictionary = appModel.diagrammerModel.diagrammer.nodesMap;
				for each (var node:* in nodesMap)
				{
					if (node is DiagramTable)
					{
						hadTables = true;
					}
					if (node is DiagramGroup)
					{
						hadGroups = true;
					}
				}
			}
			if (!hadTables && !hadGroups)
			{
				
				
				_lastSelectedLayout = layoutSelector.selectedIndex;
				var objButton:LayoutSelectorHeaderButton = LayoutSelectorHeaderButton(layoutSelector.selectedItem);
				// switches the current visual state
				currentState = objButton.state;
				// change visualizer.layoutID property
				appModel.diagrammerModel.layoutID = objButton.layoutType;
				if(layoutSelector.selectedItem.layoutType == HierarchicalLayout.ID)
				    appModel.diagrammerModel.layoutModel.edgeDrawing=4;
				title= "Layouts: "+ objButton.label;
				//update default link style
				appModel.diagrammerModel.updateDefaultLinkLine();
			}
			else
			{
				_layoutErrorPopup = PopUpManager.createPopUp(this.stage.getChildAt(0), ErrorPopup, true); // sorry about that...
				PopUpManager.centerPopUp(_layoutErrorPopup);
				ErrorPopup(_layoutErrorPopup).height = 185;
				ErrorPopup(_layoutErrorPopup).title = "Error";
				ErrorPopup(_layoutErrorPopup).showBtClose = false;
				ErrorPopup(_layoutErrorPopup).errorLabel = "Cannot rendered this layout, because there is table(s) and/or group(s) in the graph.\n\n[note:Organic animated is in beta version]";
				ErrorPopup(_layoutErrorPopup).addEventListener(Event.CLOSE, closeErrorPopupHandler);
			}
		}


		protected function closeErrorPopupHandler(event:Event):void
		{
			PopUpManager.removePopUp(_layoutErrorPopup);
			layoutSelector.selectedIndex = _lastSelectedLayout;
		}

		/**
		 * Handles change of orientation on the Hierachical tree.
		 * Whenever the orientation changes, we need to enforce the values
		 * for horizontal and vertical spacing.
		 *
		 * @param event
		 */
		protected function hierarchicalOrientation_changeHandler(event:IndexChangeEvent):void
		{
			switch (hierarchicalOrientation.selectedIndex)
			{
				case 0:
				{
					layoutModel.orientation = uint(vertical.value);
					switch (hierarchicalVerticalSpacing.selectedIndex)
					{
						case 0:
							layoutModel.layerDistance=verticalLow.value;
							break;
						case 1: 
							layoutModel.layerDistance=verticalMedium.value;
							break;
						case 2:
							layoutModel.layerDistance=verticalHigh.value;
							break;
					}
					switch (hierarchicalHorizontalSpacing.selectedIndex)
					{
						case 0:
							layoutModel.defaultNodeDistance=horizontalLow.value;
							break;
						case 1: 
							layoutModel.defaultNodeDistance=horizontalMedium.value;
							break;
						case 2:
							layoutModel.defaultNodeDistance=horizontalHigh.value;
							break;
					}
					break;
				}
					
				case 1: 
				{
					layoutModel.orientation= uint(horizontal.value);
					switch (hierarchicalVerticalSpacing.selectedIndex)
					{
						case 0:
							layoutModel.defaultNodeDistance=verticalLow.value;
							break;
						case 1: 
							layoutModel.defaultNodeDistance=verticalMedium.value;
							break;
						case 2:
							layoutModel.defaultNodeDistance=verticalHigh.value;
							break;
					} 
					switch (hierarchicalHorizontalSpacing.selectedIndex)
					{
						case 0:
							layoutModel.layerDistance=horizontalLow.value;
							break;
						case 1: 
							layoutModel.layerDistance=horizontalMedium.value;
							break;
						case 2:
							layoutModel.layerDistance=horizontalHigh.value;
							break;
					}
					
					break;
				}
					
					
			}
		}

		/**
		 * Handles change of vertical nodes spacing on the Hierarchical tree.
		 * If the layout <code>orientation</code> is vertical (top-down),
		 * then the vertical spacing is the <code>layerDistance</code>
		 * property.
		 * If the layout orientation is horizontal (left-right), then the
		 * vertical spacing is the <code>defaultNodeDistance</code>
		 * property.
		 *
		 * @param event
		 */
		protected function hierarchicalVerticalSpacing_changeHandler(event:IndexChangeEvent):void
		{
			
			if (hierarchicalOrientation.selectedIndex==0)
			{
				switch (hierarchicalVerticalSpacing.selectedIndex)
				{
					case 0:
						layoutModel.layerDistance=verticalLow.value;
						break;
					case 1: 
						layoutModel.layerDistance=verticalMedium.value;
						break;
					case 2:
						layoutModel.layerDistance=verticalHigh.value;
						break;
				}
				
			}
			else
			{
				switch (hierarchicalVerticalSpacing.selectedIndex)
				{
					case 0:
						layoutModel.defaultNodeDistance=verticalLow.value;
						break;
					case 1: 
						layoutModel.defaultNodeDistance=verticalMedium.value;
						break;
					case 2:
						layoutModel.defaultNodeDistance=verticalHigh.value;
						break;
				}
				
			}
			
		}

		/**
		 * Handles change of horizontal nodes spacing on the Hierarchical tree.
		 * If the layout <code>orientation</code> is vertical (top-down),
		 * then the horizontal spacing is the <code>defaultNodeDistance</code>
		 * property.
		 * If the layout orientation is horizontal (left-right), then the
		 * horizontal spacing is the <code>layerDistance</code> property.
		 *
		 * @param event
		 */

		protected function hierarchicalHorizontalSpacing_changeHandler(event:IndexChangeEvent):void
		{
			if (hierarchicalOrientation.selectedIndex==1)
			{
				switch (hierarchicalHorizontalSpacing.selectedIndex)
				{
					case 0:
						layoutModel.layerDistance=horizontalLow.value;
						break;
					case 1: 
						layoutModel.layerDistance=horizontalMedium.value;
						break;
					case 2:
						layoutModel.layerDistance=horizontalHigh.value;
						break;
				}
				
			}
			else
			{
				switch (hierarchicalHorizontalSpacing.selectedIndex)
				{
					case 0:
						layoutModel.defaultNodeDistance=horizontalLow.value;
						break;
					case 1: 
						layoutModel.defaultNodeDistance=horizontalMedium.value;
						break;
					case 2:
						layoutModel.defaultNodeDistance=horizontalHigh.value;
						break;
				}
				
			}
			
		}

		/**
		 * Handles change of orientation on the Hierachical cyclic
		 * (SugiyamaLayout).
		 * Whenever the orientation changes, we need to enforce the values
		 * for horizontal and vertical spacing
		 *
		 * @param event
		 */
		protected function sugiyamaOrientation_changeHandler(event:IndexChangeEvent):void
		{
			switch (sugiyamaOrientation.selectedIndex)
			{
				case 0:
				{
					layoutModel.orientation = uint(sugiyamaVertical.value);
					switch (sugiyamaVerticalSpacing.selectedIndex)
					{
						case 0:
							layoutModel.layerDistance=sugiyamaVerticalLow.value;
							break;
						case 1: 
							layoutModel.layerDistance=sugiyamaVerticalMedium.value;
							break;
						case 2:
							layoutModel.layerDistance=sugiyamaVerticalHigh.value;
							break;
					}
					switch (sugiyamaHorizontalSpacing.selectedIndex)
					{
						case 0:
							layoutModel.defaultNodeDistance=sugiyamaHorizontalLow.value;
							break;
						case 1: 
							layoutModel.defaultNodeDistance=sugiyamaHorizontalMedium.value;
							break;
						case 2:
							layoutModel.defaultNodeDistance=sugiyamaHorizontalHigh.value;
							break;
					}
					break;
				}
					
				case 1: 
				{
					layoutModel.orientation= uint(sugiyamaHorizontal.value);
					switch (sugiyamaVerticalSpacing.selectedIndex)
					{
						case 0:
							layoutModel.defaultNodeDistance=sugiyamaVerticalLow.value;
							break;
						case 1: 
							layoutModel.defaultNodeDistance=sugiyamaVerticalMedium.value;
							break;
						case 2:
							layoutModel.defaultNodeDistance=sugiyamaVerticalHigh.value;
							break;
					} 
					switch (sugiyamaHorizontalSpacing.selectedIndex)
					{
						case 0:
							layoutModel.layerDistance=sugiyamaHorizontalLow.value;
							break;
						case 1: 
							layoutModel.layerDistance=sugiyamaHorizontalMedium.value;
							break;
						case 2:
							layoutModel.layerDistance=sugiyamaHorizontalHigh.value;
							break;
					}
					
					break;
				}
					
					
			}
			
		}

		/**
		 * Handles change of vertical nodes spacing on the Hierarchical
		 * cyclic (sugiyama layout).
		 * If the layout <code>orientation</code> is vertical (top-down),
		 * then the vertical spacing is the <code>layerDistance</code>
		 * property.
		 * If the layout orientation is horizontal (left-right), then the
		 * vertical spacing is the <code>defaultNodeDistance</code>
		 * property.
		 *
		 * @param event
		 */
		protected function sugiyamaVerticalSpacing_changeHandler(event:IndexChangeEvent):void
		{
			if (sugiyamaOrientation.selectedIndex==0)
			{
				switch (sugiyamaVerticalSpacing.selectedIndex)
				{
					case 0:
						layoutModel.verticalDistance=sugiyamaVerticalLow.value;
						break;
					case 1: 
						layoutModel.verticalDistance=sugiyamaVerticalMedium.value;
						break;
					case 2:
						layoutModel.verticalDistance=sugiyamaVerticalHigh.value;
						break;
				}
				
			}
			else
			{
				switch (sugiyamaVerticalSpacing.selectedIndex)
				{
					case 0:
						layoutModel.horizontalDistance=sugiyamaVerticalLow.value;
						break;
					case 1: 
						layoutModel.horizontalDistance=sugiyamaVerticalMedium.value;
						break;
					case 2:
						layoutModel.horizontalDistance=sugiyamaVerticalHigh.value;
						break;
				}
			}
	
		}

		/**
		 * Handles change of horizontal nodes spacing on the Hierarchical
		 * cyclic  (sugiyama layout).
		 * If the layout <code>orientation</code> is vertical (top-down),
		 * then the horizontal spacing is the <code>defaultNodeDistance</code>
		 * property.
		 * If the layout orientation is horizontal (left-right), then the
		 * horizontal spacing is the <code>layerDistance</code> property.
		 *
		 * @param event
		 */
		protected function sugiyamaHorizontalSpacing_changeHandler(event:IndexChangeEvent):void
		{
			if (sugiyamaOrientation.selectedIndex==1)
			{
				switch (sugiyamaHorizontalSpacing.selectedIndex)
				{
					case 0:
						layoutModel.verticalDistance=sugiyamaHorizontalLow.value;
						break;
					case 1: 
						layoutModel.verticalDistance=sugiyamaHorizontalMedium.value;
						break;
					case 2:
						layoutModel.verticalDistance=sugiyamaHorizontalHigh.value;
						break;
				}
				
			}
			else
			{
				switch (sugiyamaHorizontalSpacing.selectedIndex)
				{
					case 0:
						layoutModel.horizontalDistance=sugiyamaHorizontalLow.value;
						break;
					case 1: 
						layoutModel.horizontalDistance=sugiyamaHorizontalMedium.value;
						break;
					case 2:
						layoutModel.horizontalDistance=sugiyamaHorizontalHigh.value;
						break;
				}
				
			}
		}

		/**
		 * The graph layout is not saved in this demo
		 * so we reset the layout buttons after we import
		 * a graph
		 **/
		public function unselectLayout():void
		{
			layoutSelector.requireSelection = false;
			layoutSelector.selectedIndex = -1;
			enableControls = false;
		}
		

		/* ***********************************
		* line Type Handlers
		***********************************/
		protected function straight_clickHandler(event:MouseEvent):void
		{
			layoutModel.edgeDrawing=EdgeDrawType.STRAIGHT_LINE;
		}
		
		protected function straightPolyline_clickHandler(event:MouseEvent):void
		{
			layoutModel.edgeDrawing=EdgeDrawType.STRAIGHT_POLYLINE;
		}
		
		protected function curvedPolyline_clickHandler(event:MouseEvent):void
		{
			layoutModel.edgeDrawing=EdgeDrawType.CURVED_POLYLINE;	
		}
		
		protected function orthogonalPolyline_clickHandler(event:MouseEvent):void
		{
			layoutModel.edgeDrawing=EdgeDrawType.ORTHOGONAL_STRAIGHT_POLYLINE;
		}
		
		protected function orthogonalCurved_clickHandler(event:MouseEvent):void
		{
			layoutModel.edgeDrawing=EdgeDrawType.ORTHOGONAL_CURVED_POLYLINE;
		}
			
		protected function orthogonalSpacing_changeHandler(event:IndexChangeEvent):void
		{
			switch (orthogonalSpacing.selectedIndex)
			{
				case 0:
					layoutModel.nodesSpacing=gridLow.value;
					break;
				case 1: 
					layoutModel.nodesSpacing=gridMedium.value;
					break;
				case 2:
					layoutModel.nodesSpacing=gridHigh.value;
					break;
			}
			
		}
		
	     /* ***********************
		 * Circular Properties Handlers
		 *****************************/
		protected function circularLayoutAngle_changeHandler(event:IndexChangeEvent):void
		{
			switch (circularLayoutAngle.selectedIndex)
			{
				case 0:
					layoutModel.angularSector=angle1.value;
					break;
				case 1:
					layoutModel.angularSector=angle2.value;
					break;
					
			}
		}
		
		
		protected function circularSpacing_changeHandler(event:IndexChangeEvent):void
		{
			switch (circularSpacing.selectedIndex)
			{
				case 0:
					layoutModel.nodesSpacing=circularLow.value;
					break;
				case 1: 
					layoutModel.nodesSpacing=circularMedium.value;
					break;
				case 2:
					layoutModel.nodesSpacing=circularHigh.value;
					break;
			}
		}
		
		protected function ballonLayoutAngle_changeHandler(event:IndexChangeEvent):void
		{
			switch (balloonLayoutAngle.selectedIndex)
			{
				case 0:
					layoutModel.rootAngularSector=angleBalloon1.value;
					break;
				case 1:
					layoutModel.rootAngularSector=angleBalloon2.value;
					break;
				
			}
		}
		
		protected function balloonLayoutChildAngle_changeHandler(event:IndexChangeEvent):void
		{
			switch (balloonLayoutChildAngle.selectedIndex)
			{
				case 0:
					layoutModel.childAngularSector=angleChildBalloon1.value;
					break;
				case 1:
					layoutModel.childAngularSector=angleChildBalloon2.value;
					break;
				
			}
		}
		protected function toggleswitch1_changeHandler(event:Event):void
		{
			layoutModel.useEvenAngles= toggleSwitchBalloon.selected;
		}
		
		/* ******************************
		 * Root Selection Policy handlers
		**********************************/
		protected function directed_clickHandler(event:MouseEvent):void
		{
			layoutModel.rootSelectionPolicy=RootSelectionType.DIRECTED_ROOT_SELECTION;
		}
		
		protected function mostClosed_clickHandler(event:MouseEvent):void
		{
			layoutModel.rootSelectionPolicy=RootSelectionType.MOST_CLOSED_ROOT_SELECTION;
		}
		
		protected function mostWeighted_clickHandler(event:MouseEvent):void
		{
			layoutModel.rootSelectionPolicy=RootSelectionType.MOST_WEIGHTED_ROOT_SELECTION;
		}
		
		protected function mostSurrounded_clickHandler(event:MouseEvent):void
		{
			layoutModel.rootSelectionPolicy=RootSelectionType.MOST_SURROUNDED_ROOT_SELECTION;
		}
		
		protected function radialLayoutAngle_changeHandler(event:IndexChangeEvent):void
		{
			switch (radialLayoutAngle.selectedIndex)
			{
				case 0:
					layoutModel.angle2=radialAngle1.value;
					break;
				case 1:
					layoutModel.angle2=radialAngle2.value;
					break;
			}
			
		}
		/* ****************************
		* Orthogonal Properties Handlers
		*********************************/
		protected function toggleSwitchOrthogonal_changeHandler(event:Event):void
		{
		    layoutModel.usePseudoOrthogonalEdges=toggleSwitchOrthogonal.selected
		}
		
		protected function this_creationCompleteHandler(event:FlexEvent):void
		{
			var objButton:LayoutSelectorHeaderButton = LayoutSelectorHeaderButton(layoutSelector.selectedItem);
			title= "Layouts: "+ objButton.label;
		}
		
	]]>
	</fx:Script>

	<components:states>
		<s:State name="HierarchicalLayout" />
		<s:State name="SugiyamaLayout" />
		<s:State name="OrthogonalLayout" />
		<s:State name="SingleCycleCircularLayout" />
		<s:State name="BalloonLayout" />
		<s:State name="RadialLayout" />
		<s:State name="StaticGEMLayout" />
	</components:states>

	<components:headerContent>
		<component:KapHeaderPanelButtonBar id="layoutSelector"
										   dataProvider="{layoutList}" selectedIndex="1"
										   requireSelection="true"
										   change="layoutSelector_changeHandler(event)"
										    horizontalCenter="5"/>
	</components:headerContent>

	<s:VGroup 
			  paddingLeft="10" paddingRight="10"
			   enabled="{enableControls}"
			  >

		<!-- Hierarchical tree -->
		<s:VGroup includeIn="HierarchicalLayout" width="100%" gap="14" paddingBottom="6" paddingTop="6">
			<s:Label paddingBottom="-8" paddingTop="0" text="Orientation" />
			
			<s:ButtonBar id="hierarchicalOrientation" labelField="label" requireSelection="true" change="hierarchicalOrientation_changeHandler(event)" horizontalCenter="0" width="100%" skinClass="fr.kapit.lab.demo.common.skins.buttonbars.CustomButtonBarSkin">
				<s:dataProvider>
					<s:ArrayCollection>
						<fx:Object id="vertical" label="Vertical"
								   value="{OrientationType.ORIENTATION_TOP_DOWN}"
								   />
						<fx:Object label="Horizontal"
								   id="horizontal"
								   value="{OrientationType.ORIENTATION_LEFT_RIGHT}"
								   />
					</s:ArrayCollection>		   
				</s:dataProvider>
				<s:layout>
					<s:HorizontalLayout gap="-1" columnWidth="101" variableColumnWidth="false" />
				</s:layout>
			</s:ButtonBar>
			<s:Label paddingBottom="-8" text="Vertical Spacing"/>
			<s:ButtonBar id="hierarchicalVerticalSpacing" labelField="label" requireSelection="true" change="hierarchicalVerticalSpacing_changeHandler(event)" horizontalCenter="0" width="100%" skinClass="fr.kapit.lab.demo.common.skins.buttonbars.CustomButtonBarSkin">
				<s:dataProvider>
					<s:ArrayCollection>
						<fx:Object id="verticalLow" label="Low"
								   value="{20}"/>
						<fx:Object  id="verticalMedium"
							        label="Medium"
									value="{60}"/>
						<fx:Object  id="verticalHigh"
									label="High"
									value="{200}"/>
					</s:ArrayCollection>		   
				</s:dataProvider>
			
					<s:layout>
						<s:HorizontalLayout gap="-2" columnWidth="67.5" variableColumnWidth="false"/>
					</s:layout>
			
				
			</s:ButtonBar>
			<s:Label paddingBottom="-8" text="Horizontal Spacing"/>
			<s:ButtonBar id="hierarchicalHorizontalSpacing" labelField="label" requireSelection="true" change="hierarchicalHorizontalSpacing_changeHandler(event)" horizontalCenter="0" width="100%" skinClass="fr.kapit.lab.demo.common.skins.buttonbars.CustomButtonBarSkin">
				<s:dataProvider>
					<s:ArrayCollection>
						<fx:Object id="horizontalLow" label="Low"
								   value="{20}"/>
						<fx:Object  id="horizontalMedium"
									label="Medium"
									value="{60}"/>
						<fx:Object  id="horizontalHigh"
									label="High"
									value="{200}"/>
					</s:ArrayCollection>		   
				</s:dataProvider>
				<s:layout>
					<s:HorizontalLayout gap="-2" columnWidth="67.5" variableColumnWidth="false"/>
				</s:layout>
			</s:ButtonBar>
			<s:VGroup width="100%" paddingLeft="-10" gap="0" >
				<fx:HSeparator />
				<s:Group width="100%" height="1">
					<s:Rect top="0" bottom="0" left="0" right="0">
						<s:fill>
							<s:SolidColor color="0xFFFFFF"/>
						</s:fill>
					</s:Rect>
				</s:Group>
			</s:VGroup>
			<s:Label paddingBottom="-8" paddingTop="0" text="Line style" />
			<s:VGroup gap="6">
				<s:RadioButton groupName="hierarchicalTreeLineType" 
							   id="straight"
							   label="Straight" 
							   width="150"
							   click="straight_clickHandler(event)"/>
				<s:RadioButton groupName="hierarchicalTreeLineType" 
							   id="straightPolyline"
							   label="Straight Polyline" 
							   width="150"
							   click="straightPolyline_clickHandler(event)"/>
				<s:RadioButton groupName="hierarchicalTreeLineType" 
							   id="curvedPolyline"
							   label="Curved Polyline" 
							   width="150"
							   click="curvedPolyline_clickHandler(event)"/>    
				<s:RadioButton groupName="hierarchicalTreeLineType" 
							   id="orthogonalPolyline"
							   label="Orthogonal Polyline" 
							   width="150"
							   click="orthogonalPolyline_clickHandler(event)"/>    
				<s:RadioButton groupName="hierarchicalTreeLineType" 
							   id="orthogonalCurved"
							   label="Orthogonal Curved" 
							   selected="true"
							   width="150" click="orthogonalCurved_clickHandler(event)"/>    
			</s:VGroup>
			
		</s:VGroup>

		<!-- Hierarchical cyclic -->
		<s:VGroup includeIn="SugiyamaLayout" width="100%" gap="14" paddingBottom="6" paddingTop="6">
			<s:Label paddingBottom="-8" paddingTop="0" text="Orientation"  />
			<s:ButtonBar id="sugiyamaOrientation" labelField="label" requireSelection="true" change="sugiyamaOrientation_changeHandler(event)" horizontalCenter="0" width="100%" skinClass="fr.kapit.lab.demo.common.skins.buttonbars.CustomButtonBarSkin">
				<s:dataProvider>
					<s:ArrayCollection>
						<fx:Object id="sugiyamaVertical" label="Vertical"
								   value="{OrientationType.ORIENTATION_TOP_DOWN}"
								   />
						<fx:Object label="Horizontal"
								   id="sugiyamaHorizontal"
								   value="{OrientationType.ORIENTATION_LEFT_RIGHT}"
								   />
					</s:ArrayCollection>		   
				</s:dataProvider>
				<s:layout>
					<s:HorizontalLayout gap="-1" columnWidth="101" variableColumnWidth="false" />
				</s:layout>
			</s:ButtonBar>			
			<s:Label paddingBottom="-8" text="Vertical Spacing"/>
			<s:ButtonBar id="sugiyamaVerticalSpacing" labelField="label" requireSelection="true" change="sugiyamaVerticalSpacing_changeHandler(event)" horizontalCenter="0" width="100%" skinClass="fr.kapit.lab.demo.common.skins.buttonbars.CustomButtonBarSkin">
				<s:dataProvider>
					<s:ArrayCollection>
						<fx:Object id="sugiyamaVerticalLow" label="Low"
								   value="{20}"/>
						<fx:Object  id="sugiyamaVerticalMedium"
									label="Medium"
									value="{60}"/>
						<fx:Object  id="sugiyamaVerticalHigh"
									label="High"
									value="{200}"/>
					</s:ArrayCollection>		   
				</s:dataProvider>
				<s:layout>
					<s:HorizontalLayout gap="-2" columnWidth="67.5" variableColumnWidth="false"/>
				</s:layout>
			</s:ButtonBar>
			<s:Label paddingBottom="-8" text="Horizontal Spacing"/>
			<s:ButtonBar id="sugiyamaHorizontalSpacing" labelField="label" requireSelection="true" change="sugiyamaHorizontalSpacing_changeHandler(event)" horizontalCenter="0" width="100%" skinClass="fr.kapit.lab.demo.common.skins.buttonbars.CustomButtonBarSkin">
				<s:dataProvider>
					<s:ArrayCollection>
						<fx:Object id="sugiyamaHorizontalLow" label="Low"
								   value="{20}"/>
						<fx:Object  id="sugiyamaHorizontalMedium"
									label="Medium"
									value="{60}"/>
						<fx:Object  id="sugiyamaHorizontalHigh"
									label="High"
									value="{200}"/>
					</s:ArrayCollection>		   
				</s:dataProvider>
				<s:layout>
					<s:HorizontalLayout gap="-2" columnWidth="67.5" variableColumnWidth="false"/>
				</s:layout>
			</s:ButtonBar>
			<s:VGroup width="100%" paddingLeft="-10" gap="0" >
				<fx:HSeparator />
				<s:Group width="100%" height="1">
					<s:Rect top="0" bottom="0" left="0" right="0">
						<s:fill>
							<s:SolidColor color="0xFFFFFF"/>
						</s:fill>
					</s:Rect>
				</s:Group>
			</s:VGroup>
			<s:Label paddingBottom="-8"  text="Line style" />
			<s:VGroup gap="6">
				<s:RadioButton groupName="hierarchicalCyclicLineType" 
							   id="sugiyamaStraight"
							   label="Straight" 
							   width="150"
							   click="straight_clickHandler(event)"/>
				<s:RadioButton groupName="hierarchicalCyclicLineType" 
							   id="sugiyamaStraightPolyline"
							   label="Straight Polyline" 
							   width="150"
							   click="straightPolyline_clickHandler(event)"/>
				<s:RadioButton groupName="hierarchicalCyclicLineType" 
							   id="sugiyamaCurvedPolyline"
							   label="Curved Polyline" 
							   width="150"
							   click="curvedPolyline_clickHandler(event)"/>    
				<s:RadioButton groupName="hierarchicalCyclicLineType" 
							   id="sugiyamaOrthogonalPolyline"
							   label="Orthogonal Polyline" 
							   width="150"
							   click="orthogonalPolyline_clickHandler(event)"/>    
				<s:RadioButton groupName="hierarchicalCyclicLineType" 
							   id="sugiyamaOrthogonalCurved"
							   label="Orthogonal Curved" 
							   selected="true"
							   width="150" click="orthogonalCurved_clickHandler(event)"/>    
			</s:VGroup>
		
		</s:VGroup>


		<!-- Orthogonal -->
		<s:VGroup includeIn="OrthogonalLayout" width="100%" gap="14" paddingBottom="6" paddingTop="6">
			<s:Label paddingBottom="-8" paddingTop="0" text="Grid Spacing" />
			<s:ButtonBar id="orthogonalSpacing" labelField="label" requireSelection="true" change="orthogonalSpacing_changeHandler(event)" horizontalCenter="0" width="100%" skinClass="fr.kapit.lab.demo.common.skins.buttonbars.CustomButtonBarSkin">
				<s:dataProvider>
					<s:ArrayCollection>
						<fx:Object id="gridLow" label="Low"
								   value="{20}"/>
						<fx:Object  id="gridMedium"
									label="Medium"
									value="{60}"/>
						<fx:Object  id="gridHigh"
									label="High"
									value="{200}"/>
					</s:ArrayCollection>		   
				</s:dataProvider>
				<s:layout>
					<s:HorizontalLayout gap="-2" columnWidth="67.5" variableColumnWidth="false"/>
				</s:layout>
			</s:ButtonBar>
			<s:Label paddingBottom="-8" text="Diagonal Edges" />
			<components:ToggleSwitch  id="toggleSwitchOrthogonal" width="60" height="28" selectedLabel="ON" deselectedLabel="OFF" change="toggleSwitchOrthogonal_changeHandler(event)" />

		</s:VGroup>

		<!-- Circular -->
		<s:VGroup includeIn="SingleCycleCircularLayout" width="100%" gap="14" paddingBottom="6" paddingTop="6">
			<s:Label paddingBottom="-8" paddingTop="0"  text="Layout angle" />
			<s:ButtonBar id="circularLayoutAngle" labelField="label" requireSelection="true" change="circularLayoutAngle_changeHandler(event)" horizontalCenter="0" width="100%" skinClass="fr.kapit.lab.demo.common.skins.buttonbars.CustomButtonBarSkin">
				<s:dataProvider>
					<s:ArrayCollection>
						<fx:Object id="angle1" label="360°" value="{360}" hint="360" />
						<fx:Object id="angle2" label="180°" value="{180}" hint="180" />
					</s:ArrayCollection>		   
				</s:dataProvider>
				<s:layout>
					<s:HorizontalLayout gap="-1" columnWidth="101" variableColumnWidth="false" />
				</s:layout>			
			</s:ButtonBar>
			<s:Label paddingBottom="-8"  text="Nodes spacing" />
			<s:ButtonBar id="circularSpacing" labelField="label" requireSelection="true" change="circularSpacing_changeHandler(event)" horizontalCenter="0" width="100%" verticalCenter="0" skinClass="fr.kapit.lab.demo.common.skins.buttonbars.CustomButtonBarSkin">
				<s:dataProvider>
					<s:ArrayCollection>
						<fx:Object id="circularLow" label="Low"
								   value="{20}"/>
						<fx:Object  id="circularMedium"
									label="Medium"
									value="{60}"/>
						<fx:Object  id="circularHigh"
									label="High"
									value="{200}"/>
					</s:ArrayCollection>		   
				</s:dataProvider>
				<s:layout>
					<s:HorizontalLayout gap="-2" columnWidth="67.5" variableColumnWidth="false"/>
				</s:layout>
			</s:ButtonBar>
		</s:VGroup>


		<!-- Balloon -->
		<s:VGroup includeIn="BalloonLayout" width="100%" gap="14" paddingBottom="6" paddingTop="6">
			<s:Label paddingBottom="-8" paddingTop="0" text="Route wedge angle" />
			<s:ButtonBar id="balloonLayoutAngle" labelField="label" requireSelection="true" change="ballonLayoutAngle_changeHandler(event)" horizontalCenter="0" width="100%" skinClass="fr.kapit.lab.demo.common.skins.buttonbars.CustomButtonBarSkin">
				<s:dataProvider>
					<s:ArrayCollection>
						<fx:Object id="angleBalloon1" label="360°" value="{360}" hint="360" />
						<fx:Object id="angleBalloon2" label="180°" value="{180}" hint="180" />
					</s:ArrayCollection>		   
				</s:dataProvider>
				<s:layout>
					<s:HorizontalLayout gap="-1" columnWidth="101" variableColumnWidth="false" />
				</s:layout>
			</s:ButtonBar>
			<s:Label paddingBottom="-8" text="Child wedge angle" />
			<s:ButtonBar id="balloonLayoutChildAngle" labelField="label" requireSelection="true" change="balloonLayoutChildAngle_changeHandler(event)" horizontalCenter="0" width="100%" skinClass="fr.kapit.lab.demo.common.skins.buttonbars.CustomButtonBarSkin">
				<s:dataProvider>
					<s:ArrayCollection>
						<fx:Object id="angleChildBalloon1" label="360°" value="{360}" hint="360" />
						<fx:Object id="angleChildBalloon2" label="180°" value="{180}" hint="180" />
					</s:ArrayCollection>		   
				</s:dataProvider>
				<s:layout>
					<s:HorizontalLayout gap="-1" columnWidth="101" variableColumnWidth="false" />
				</s:layout>
			</s:ButtonBar>
			<s:VGroup width="100%" paddingLeft="-10" gap="0">
				<fx:HSeparator />
				<s:Group width="100%" height="1">
					<s:Rect top="0" bottom="0" left="0" right="0">
						<s:fill>
							<s:SolidColor color="0xFFFFFF"/>
						</s:fill>
					</s:Rect>
				</s:Group>
			</s:VGroup>
			<s:Label paddingBottom="-8" text="Root Selection Policy" />
			<s:VGroup gap="6">
				<s:RadioButton groupName="balloonRootSelectionType" 
							   id="directed"
							   label="Directed" 
							   width="150"
							   selected="true"
							   click="directed_clickHandler(event)"/>
				<s:RadioButton groupName="balloonRootSelectionType" 
							   id="mostClosed"
							   label="Most Closed" 
							   width="150"
							   click="mostClosed_clickHandler(event)"/>
				<s:RadioButton groupName="balloonRootSelectionType" 
							   id="mostSurrounded"
							   label="Most Surrounded" 
							   width="150"
							   click="mostSurrounded_clickHandler(event)"/>   
				<s:RadioButton groupName="balloonRootSelectionType" 
							   id="mostWeighted"
							   label="Most weighted" 
							   width="150"
							   click="mostWeighted_clickHandler(event)"/>  
			</s:VGroup>
			    
			
			<s:Label paddingBottom="-8" text="Equal Angle Distribution" />
			<components:ToggleSwitch  id="toggleSwitchBalloon" width="60" height="28" selectedLabel="ON" deselectedLabel="OFF" change="toggleswitch1_changeHandler(event)" />
		</s:VGroup>


		<!-- Radial -->
		<s:VGroup includeIn="RadialLayout" width="100%" gap="14" paddingBottom="6" paddingTop="6" >
			<s:Label paddingBottom="-8" paddingTop="0" text="Layout Angle" />
			<s:ButtonBar id="radialLayoutAngle" labelField="label" requireSelection="true" change="radialLayoutAngle_changeHandler(event)" horizontalCenter="0" width="100%" skinClass="fr.kapit.lab.demo.common.skins.buttonbars.CustomButtonBarSkin">
				<s:dataProvider>
					<s:ArrayCollection>
						<fx:Object id="radialAngle1" label="360°" value="{360}" hint="360" />
						<fx:Object id="radialAngle2" label="180°" value="{180}" hint="180" />
					</s:ArrayCollection>		   
				</s:dataProvider>
				<s:layout>
					<s:HorizontalLayout gap="-1" columnWidth="101" variableColumnWidth="false" />
				</s:layout>
			</s:ButtonBar>
			<s:VGroup width="100%" paddingLeft="-10" gap="0">
				<fx:HSeparator />
				<s:Group width="100%" height="1">
					<s:Rect top="0" bottom="0" left="0" right="0">
						<s:fill>
							<s:SolidColor color="0xFFFFFF"/>
						</s:fill>
					</s:Rect>
				</s:Group>
			</s:VGroup>
			<s:Label paddingBottom="-8"  text="Root Selection Policy" />
			<s:VGroup gap="6">
				<s:RadioButton groupName="radialRootSelectionType" 
							   label="Directed" 
							   width="150"
							   id="radialDirected"
							   selected="true"
							   click="directed_clickHandler(event)"/>
				<s:RadioButton groupName="radialRootSelectionType" 
							   label="Most Closed" 
							   id="radialMostClosed"
							   width="150"
							   click="mostClosed_clickHandler(event)"/>
				<s:RadioButton groupName="radialRootSelectionType" 
							   label="Most Surrounded" 
							   id="radialMostSurrounded"
							   width="150"
							   click="mostSurrounded_clickHandler(event)"/>   
				<s:RadioButton groupName="radialRootSelectionType" 
							   label="Most weighted"
							   id="radialMostWeighted"
							   width="150"
							   click="mostWeighted_clickHandler(event)"/>   
			</s:VGroup>
			   	
		</s:VGroup>

		<!-- Organic -->
		<s:VGroup includeIn="StaticGEMLayout" width="100%" gap="14" paddingBottom="6" paddingTop="6">
			<s:Label text="There are no properties for this layout" color="#cccccc" paddingBottom="-5" paddingTop="10" height="100%"/>
		</s:VGroup>
		
	</s:VGroup>
</components:OptionsPanel>
